
// HACK: putting this here instead of in `ModelViewer.spire`
// so that we can actually look it up...
module PerFrameCB_T
{
    public param LightData gDirLight;
    public param LightData gPointLight;

//    param uint gConstColor;

    public param vec3 gAmbient;
}


template shader ModelViewerShader(
	PerFrameCB : PerFrameCB_T,
	InternalPerFrameCB : InternalPerFrameCB_T,
	InternalPerMeshCB : InternalPerMeshCB_T,
	M : Material,
	VertexAttribs : IVertexAttribs,  // hack: put components that does not generate a uniform buffer last to avoid incomplete pso
	) targets StandardPipeline
{
	using perFrame = PerFrameCB();
	using internalPerFrame = InternalPerFrameCB();
	using internalPerMesh = InternalPerMeshCB();
	using VertexAttribs;

	// TODO: the per-vertex logic here should actually go in a shared "default vertex shader" component

	// HACK(foley): Making this explicitly per-vertex so that `sv_instanceID` isn't live downstream,
	// because if it is, then the Spire compiler fails on trying to propagate it along...
	@CoarseVertex mat4 worldMat = internalPerMesh.gWorldMat[sv_instanceID];

	vec3 pos = (worldMat * vec4(vertPos, 1.0)).xyz;
	vec3 normal = normalize((worldMat * vec4(vertNormal, 0.0)).xyz);
	vec3 bitangent = normalize((worldMat * vec4(vertBitangent, 0.0)).xyz);

	public vec4 projCoord = internalPerFrame.viewProjMat * vec4(pos, 1.0);

	using material = M();

    public out @Fragment vec4 outputColor
	{
		ShadingAttribs shAttr;
		material.prepareShadingAttribs(pos, internalPerFrame.position, normal, bitangent, vertUV, 0.0f, shAttr);
		
		ShadingOutput output;
		InitializeShadingOutput(output);

		material.evalMaterial(shAttr, perFrame.gDirLight, output);
		material.evalMaterial(shAttr, perFrame.gPointLight, output);
		return vec4(output.finalValue, 1.0);
	}
}