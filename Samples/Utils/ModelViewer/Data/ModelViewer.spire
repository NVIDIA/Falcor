template shader ModelViewerShader(
	PerFrameCB : PerFrameCB_T,
	InternalPerFrameCB : InternalPerFrameCB_T,
	InternalPerMeshCB : InternalPerMeshCB_T,
	M : Material,
	VertexAttribs : IVertexAttribs,  // hack: put components that does not generate a uniform buffer last to avoid incomplete pso
	) targets StandardPipeline
{
	using perFrame = PerFrameCB();
	using internalPerFrame = InternalPerFrameCB();
	using internalPerMesh = InternalPerMeshCB();
	using VertexAttribs;

	vec3 pos = (internalPerMesh.gWorldMat * vec4(vertPos, 1.0)).xyz;
	vec3 normal = normalize((internalPerMesh.gWorldMat * vec4(vertNormal, 0.0)).xyz);
	vec3 bitangent = normalize((internalPerMesh.gWorldMat * vec4(vertBitangent, 0.0)).xyz);

	public vec4 projCoord = internalPerFrame.viewProjMat * vec4(pos, 1.0);

	using material = M();

    public out @Fragment vec4 outputColor
	{
		ShadingAttribs shAttr;
		material.prepareShadingAttribs(pos, internalPerFrame.position, normal, bitangent, vertUV, 0.0f, shAttr);
		
		ShadingOutput output;
		InitializeShadingOutput(output);

		material.evalMaterial(shAttr, perFrame.gDirLight, output);
		material.evalMaterial(shAttr, perFrame.gPointLight, output);
		return vec4(output.finalValue, 1.0);
	}
}