pipeline StandardPipeline
{
    [Pinned]
    input world MeshVertex;

    world CoarseVertex;// : "glsl(vertex:projCoord)" using projCoord export standardExport;
    world Fragment;// : "glsl" export fragmentExport;
    
    require @CoarseVertex vec4 projCoord; 
        
    [VertexInput]
    extern @CoarseVertex MeshVertex vertAttribIn;
    import(MeshVertex->CoarseVertex) vertexImport()
    {
        return project(vertAttribIn);
    }
    
    extern @Fragment CoarseVertex CoarseVertexIn;
    import(CoarseVertex->Fragment) standardImport<T>()
        require trait IsTriviallyPassable(T)
    {
        return project(CoarseVertexIn);
    }
    
    stage vs : VertexShader
    {
        World: CoarseVertex;
        Position: projCoord;
    }
    
    stage fs : FragmentShader
    {
        World: Fragment;
    }
}

struct CameraData
{
    mat4            viewMat;//                DEFAULTS(mat4());                ///< Camera view matrix.
    mat4            projMat;//                DEFAULTS(mat4());                ///< Camera projection matrix.
    mat4            viewProjMat;//            DEFAULTS(mat4());                ///< Camera view-projection matrix.
    mat4            invViewProj;//			   DEFAULTS(mat4());                ///< Camera inverse view-projection matrix.
    mat4            prevViewProjMat;//        DEFAULTS(mat4());                ///< Camera view-projection matrix associated to previous frame.

    vec3            position;//               DEFAULTS(vec3(0, 0, 0));         ///< Camera world-space position.
    float           fovY;//                   DEFAULTS(1.f);                   ///< vertical field-of-view, in radians
    vec3            up;//                     DEFAULTS(vec3(0, 1, 0));         ///< Camera world-space up vector.
    float           aspectRatio;//            DEFAULTS(1.f);                   ///< Camera aspect ratio.
    vec3            target;//                 DEFAULTS(vec3(0, 0, -1));        ///< Camera target point in world-space.
    float           nearZ;//                  DEFAULTS(0.1f);                  ///< Camera near plane.
    vec3            cameraU;//                DEFAULTS(vec3(0, 0, 1));         ///< Camera base vector U. normalized it indicates the left image plane vector. The length is dependent on the FOV. 
    float           farZ;//                   DEFAULTS(10000.0f);              ///< Camera far plane.
    vec3            cameraV;//                DEFAULTS(vec3(0, 1, 0));         ///< Camera base vector V. normalized it indicates the up image plane vector. The length is dependent on the FOV. 
    float           jitterX;//                DEFAULTS(0.0f);                  ///< Eventual camera jitter in the x coordinate
    vec3            cameraW;//                DEFAULTS(vec3(1, 0, 0));         ///< Camera base vector U. normalized it indicates the forward direction. The length is the camera focal distance.
    float           jitterY;//                DEFAULTS(0.0f);                  ///< Eventual camera jitter in the y coordinate

    mat4            rightEyeViewMat;
    mat4            rightEyeProjMat;
    mat4            rightEyeViewProjMat;
    mat4            rightEyePrevViewProjMat;
}

module InternalPerFrameCB_T
{
	CameraData gCam;
}


// HACK: putting this here instead of in `ModelViewer.spire`
// so that we can actually look it up...
module PerFrameCB_T
{
//    LightData gDirLight;
//    LightData gPointLight;

//    param uint gConstColor;

    param vec3 gAmbient;
}
