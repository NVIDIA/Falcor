/***************************************************************************
# Copyright (c) 2015, NVIDIA CORPORATION. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#  * Neither the name of NVIDIA CORPORATION nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
***************************************************************************/

// Gui.{vs,ps} translated to Spire



// cbuffer PerFrameCB : register(b0)
module XGuiParams_T
{
    param float4x4 projMat;
    param float3 textColor;

	param SamplerState gSampler;
	param Texture2D gFont;
}

template shader GuiShader(
	GuiParams : XGuiParams_T)
	targets StandardPipeline
{
	using params = GuiParams();

//	struct VsIn
//	{
//		float2 pos : POSITION;
//		float4 color : COLOR;
//		float2 texC : TEXCOORD0;
//	};
	public @MeshVertex vec2 POSITION;	vec2 ia_pos	= POSITION;
	public @MeshVertex vec4 COLOR;		vec4 color	= COLOR;
	public @MeshVertex vec2 TEXCOORD;	vec2 texC	= TEXCOORD;

// struct VsOut
// {
//     float4 color : COLOR;
//     float2 texC : TEXCOORD0;
//     float4 pos : SV_POSITION;
// };

// VsOut main(VsIn vIn)
// {
//		VsOut vOut;
//		vOut.color = vIn.color;
//		vOut.texC = vIn.texC;
//		vOut.pos = mul(projMat, float4(vIn.pos, 0, 1));
//		return vOUt;
// }

	public vec4 projCoord = params.projMat * vec4(ia_pos, 0.0, 1.0);

// float4 main(VsOut vOut) : SV_TARGET
// {
//     float4 c = vOut.color;
//     float fontAlpha = gFont.Sample(gSampler, vOut.texC).a;
//     c *= float4((fontAlpha * textColor), fontAlpha);
//     return c;
// }

	float fontAlpha = params.gFont.Sample(params.gSampler, texC).a;
	float4 c = color * float4((fontAlpha * params.textColor), fontAlpha);
	public out @Fragment vec4 sv_target = c;
}
