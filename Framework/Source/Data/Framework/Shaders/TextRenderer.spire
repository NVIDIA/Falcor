/***************************************************************************
# Copyright (c) 2015, NVIDIA CORPORATION. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#  * Neither the name of NVIDIA CORPORATION nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
***************************************************************************/

// Gui.{vs,fs} translated to Spire

//#version 440
//#include "HlslGlslCommon.h"
//
//CONSTANT_BUFFER(PerFrameCB, 0)
//{
//	mat4 gvpTransform;
//	vec3 gFontColor;
//};

//Texture2D gFontTex;

module TextRendererParams_T
{
	param mat4 gvpTransform;
	param vec3 gFontColor;

	param Texture2D gFontTex;

	// SPIRE: TODO: should not be needed
	param SamplerState gSampler;
}

template shader TextRendererShader(
	TextRendererParams : TextRendererParams_T)
	targets StandardPipeline
{
	using params = TextRendererParams();

//vec4 transform(vec2 posS)
//{
//	return mul(gvpTransform, vec4(posS, 0.5f, 1));
//}

	vec4 transform(vec2 posS)
	{
		return params.gvpTransform * vec4(posS, 0.5f, 1);
	}

//#ifdef FALCOR_HLSL
//void main(float2 posS : POSITION, inout float2 texC : TEXCOORD, out float4 posSV : SV_POSITION)
//{
//	posSV = transform(posS);
//}

	public @MeshVertex vec2 POSITION;	vec2 posS = POSITION;
	public @MeshVertex vec2 TEXCOORD;	vec2 texC = TEXCOORD;

	public vec4 projCoord = transform(posS);

//vec4 calcColor(vec2 texC)
//{
//	vec4 color = gFontTex.Load(ivec3(texC, 0));
//	color.rgb = gFontColor;
//	return color;
//}

	vec4 calcColor(vec2 texC)
	{
		// SPIRE: TODO: use `Load` instead of `Sample`
		vec4 color = params.gFontTex.Load(ivec3(int(texC.x), int(texC.y), 0));
//		vec4 color = params.gFontTex.Sample(params.gSampler, texC);

		color.rgb = params.gFontColor;
		return color;
	}

//vec4 main(float2 texC  : TEXCOORD) : SV_TARGET0
//{
//	return calcColor(texC);
//}

	public out @Fragment vec4 sv_target = calcColor(texC);

}
