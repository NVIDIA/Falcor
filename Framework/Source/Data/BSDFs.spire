#include "ShaderConstants.spire"

#define _ref(x) inout x


/**********************************************************************************
BRDF helpers
**********************************************************************************/

/*******************************************************************
                    Shared material routines
*******************************************************************/


/** Converts specular power to roughness. Note there is no "the conversion".
    Reference: http://simonstechblog.blogspot.com/2011/12/microfacet-brdf.html
    \param shininess specular power of an obsolete Phong BSDF
*/
float convertShininessToRoughness(const float shininess)
{
    return clamp(sqrt(2.0f / (shininess + 2.0f)), 0.f, 1.f);
}

vec2 convertShininessToRoughness(const vec2 shininess)
{
    return clamp(sqrt(2.0f / (shininess + 2.0f)), 0.f, 1.f);
}

float convertRoughnessToShininess(const float a)
{
    return 2.0f / clamp(a*a, 1e-8f, 1.f) - 2.0f;
}

vec2 convertRoughnessToShininess(const vec2 a)
{
    return 2.0f / clamp(a*a, 1e-8f, 1.f) - 2.0f;
}

/**********************************************************************************
Microfacet routines: Fresnel (conductor/dielectric), shadowing/masking
**********************************************************************************/

/**
Schlick's approximation for reflection of a dielectric media
*/
float dielectricFresnelSchlick(in float VdH, in float IoR)
{
    float R0 = (1.f - IoR) / (1.f + IoR);	R0 *= R0;
    float OneMinusCos = 1.f - VdH;
    float OneMinusCos2 = OneMinusCos*OneMinusCos;
    return R0 + (1.f - R0) * OneMinusCos*OneMinusCos2*OneMinusCos2;	// to the power of 5
}

/**
Simplified Fresnel factor (w/o polarization) of a planar interface
between two dielectrics
*/
float dielectricFresnelFast(in float NdE, in float NdL, in float IoR)
{
    float Rs = (NdE - IoR * NdL) / (NdE + IoR * NdL);	// Transmitted-to-incident wave ratio, perpendicular component
    float Rp = (IoR * NdE - NdL) / (IoR * NdE + NdL);	// Transmitted-to-incident wave ratio, parallel component
    return (Rs * Rs + Rp * Rp) * 0.5f;						// Total amplitude of the transmitted wave
}

/**
Full Fresnel factor (w/o polarization) of a planar interface
between two dielectrics
*/
float dielectricFresnel(in float NdE, in float IoR)
{
    float realIoR = (NdE >= 0.f) ? 1.f / IoR : IoR;
    // Perform a refraction
    float NdL2 = 1.f - realIoR * realIoR * (1.f - NdE * NdE);
    if(NdL2 <= 0.f)	// Total internal reflection case
        return 1.f;
    float NdL = sqrt(NdL2);
    NdE = abs(NdE);		// Wrap the incident direction
    float Rp = (IoR * NdL - NdE) / (IoR * NdL + NdE);	// Reflected-to-incident wave ratio, parallel component
    float Rs = (NdE - IoR * NdL) / (NdE + IoR * NdL);	// Reflected-to-incident wave ratio, parallel component
    return (Rp * Rp + Rs * Rs) * 0.5f;						// Total amplitude of the reflected wave
}

/**
Full Fresnel factor (w/o polarization) of a planar interface
between a dielectric (usually air) and a conductive media
*/
float conductorFresnel(in float NdE, in float IoR, in float Kappa)
{
    float Kappa2 = Kappa * Kappa;
    float TotalIoR2 = IoR * IoR + Kappa2;	// Total magnitude of IoR: Real plus complex parts of IoR
    NdE = saturate(NdE);			// No refraction allowed
    float NdE2 = NdE * NdE;
    float ReducedNdE2 = TotalIoR2 * NdE2;
    float Rp2 = (ReducedNdE2 - IoR * NdE * 2.f + 1.f) / (ReducedNdE2 + IoR * NdE * 2.f + 1.f);	// Reflected-to-incident wave ratio, perpendicular component
    float Rs2 = (TotalIoR2 - IoR * NdE * 2.f + NdE2) / (TotalIoR2 + IoR * NdE * 2.f + NdE2);		// Reflected-to-incident wave ratio, parallel component
    return (Rp2 + Rs2) * 0.5f;					// Total amplitude of the reflected wave
}

/**********************************************************************************
Distribution functions
**********************************************************************************/

/*******************************************************************************************
Lambertian diffuse BSDF. Returns a clamped N.L factor.
*/
float evalDiffuseBSDF(in vec3 shadeNormal, in vec3 lightDir)
{
    return max(0.f, dot(shadeNormal, lightDir)) * M_1_PIf;
}

/*******************************************************************************************
Blinn-Phong normal distribution function (NDF).
*/
float evalPhongDistribution(in vec3 N, in vec3 V, in vec3 L, in float roughness)
{
    float spec_power = convertRoughnessToShininess(roughness);
    vec3 H = normalize(L + V);
    float NoH = max(0.f, dot(N, H));
    float normalization = (spec_power + 2.f) / (2.f * M_PIf);
    return pow(NoH, spec_power) * normalization;
}

/*******************************************************************************************
Beckmann normal distribution function (NDF).
*/
float evalBeckmannDistribution(in vec3 N, in vec3 H, in float roughness)
{
    float a2 = roughness * roughness;
    // dot products that we need
    float NoH = dot(N, H);
    float NoH2 = NoH * NoH;
    // Compute Beckmann distribution
    float exponent = max(0.f, (1.f - NoH2) / (a2 * NoH2));
    return exp(-exponent) / (M_PIf * a2 * NoH2 * NoH2);
}

float evalBeckmannDistribution(in vec3 H, in vec2 rgns)
{
    float NoH2 = H.z * H.z;
    vec2 Hproj = vec2(H.x, H.y);
    // Compute Beckmann distribution
    float exponent = dot(Hproj / (rgns*rgns), Hproj) / NoH2;
    return exp(-exponent) / (M_PIf * rgns.x * rgns.y * NoH2 * NoH2);
}

/**
Returns a standard deviation of the Beckmann distribution
as a cone apex angle in parallel plane domain based on the roughness.
*/
float beckmannStdDevAngle(in float roughness)
{
    return atan(sqrt(0.5f) * roughness);
}

/**
An approximation of the off specular peak;
due to the other approximations we found this one performs better than Frostbite PBS'15.
N is the normal direction
R is the mirror vector
This approximation works fine for G smith correlated and uncorrelated
*/
vec3 getBeckmannDominantDir(in vec3 N, in vec3 R,
    in float roughness)
{
    float smoothness = clamp(1.f - roughness, 0.0f, 1.0f);
    float lerpFactor = smoothness * (sqrt(smoothness) + roughness);
    // The result is not normalized as we fetch in a cubemap
    return lerp(N, R, lerpFactor);
}


/*******************************************************************************************
GGX normal distribution function (NDF).
*/
float evalGGXDistribution(in vec3 N, in vec3 H, in float roughness)
{
    // This doesn't look correct, so disabled    
    float a2 = roughness * roughness;
    // dot products that we need
    float NoH = saturate(dot(N, H));
    // D term
    float D_denom = (NoH * a2 - NoH) * NoH + 1.0f;
    D_denom = M_PIf * D_denom * D_denom;
    return a2 / D_denom;
}

float evalGGXDistribution(in vec3 H, in vec2 rgns)
{
    // Numerically robust (w.r.t rgns=0) implementation of anisotropic GGX
    float anisoU = rgns.y < rgns.x ? rgns.y / rgns.x : 1.f;
    float anisoV = rgns.x < rgns.y ? rgns.x / rgns.y : 1.f;
    float r = min(rgns.x, rgns.y);
    float NoH2 = H.z * H.z;
    vec2 Hproj = vec2(H.x, H.y);
    float exponent = dot(Hproj / vec2(anisoU*anisoU, anisoV*anisoV), Hproj);
    float root = NoH2 * r*r + exponent;
    return r*r / (M_PIf * anisoU * anisoV * root * root);
}

/*******************************************************************************************
Compute shadowing and masking
*******************************************************************************************/

/**
Computes the intermediate effective microfacet roughness observed from a particular direction
\param[in] dir view direction in local shading frame
\param[in] rghns original anisotropic roughness of the microfacet BSDF
returns effective visible roughness
*/
float effectiveVisibleRoughness(in vec3 dir, in vec2 rghns)
{
    float recipSinThSq = 1.f / (1.f - dir.z * dir.z);
    vec2 dirPlane = vec2(dir.x, dir.y);
    vec2 cosSinPhiSq = dirPlane * dirPlane * recipSinThSq;
    vec2 res = rghns * rghns * cosSinPhiSq;
    return sqrt(res.x + res.y);
}

/**
Computes the Smith'67 shadowing or masking term from a direction.
\param[in] dir view direction in local shading frame
\param[in] h half vector (microfacet direction) in local shading frame
\param[in] rghns original anisotropic roughness of the microfacet BSDF
\param[in] ndfType type of NDF. Only Beckmann and GGX are supported so far
returns amount of visible microfacets
*/
float GSmith(in vec3 dir, in vec3 h, in vec2 rghns, in uint ndfType)
{
    if(dot(dir, h) * dir.z <= 0.f)
        return 0.f;
    float sinThSq = 1.f - dir.z * dir.z;
    if(sinThSq <= 0.f)
        return 1.f;
    float recipSlope = sqrt(sinThSq) / dir.z;
    float alpha = effectiveVisibleRoughness(dir, rghns);
    if (ndfType == NDFBeckmann)
    {
        // Use the Beckmann G fit from [Walter07]
        float a = 1.f / (alpha * recipSlope);
        if(a > 1.6f)
            return 1.f;
        float aSq = a*a;
        return (3.535f * a + 2.181f * aSq) / (1.f + 2.276f * a + 2.577f * aSq);
    }

    // Otherwise it's GGX, use GGX shadowing/masking
    float isectRoot = alpha * recipSlope;
    return 2.f / (1.f + length(vec2(1.f, isectRoot)));
}

/**
Computes shadowing and masking term for microfacet BRDFs
*/
float evalMicrofacetTerms(in vec3 T, in vec3 B, in vec3 N,
    in vec3 h, in vec3 V, in vec3 L,
    in vec2 roughness, in uint ndfType, bool transmissive)
{
    vec3 lTg = vec3(dot(T, L), dot(B, L), dot(N, L));
    vec3 vTg = vec3(dot(T, V), dot(B, V), dot(N, V));

    /* If it's not transmission, they should be on the same side of the hemisphere */
    if(!transmissive && lTg.z*vTg.z <= 0.f)
        return 0.f;

    /* Compute shadowing and masking separately */
    return GSmith(vTg, h, roughness, ndfType) * GSmith(lTg, h, roughness, ndfType);
}

/*******************************************************************************************
    Sampling functions
*******************************************************************************************/

/**
    Sample the microfacet BRDF using Beckmann normal distribution function

    \param[in] wo Outgoing direction towards the camera
    \param[in] roughness Material roughness
    \param[in] rSample Random numbers for sampling
    \param[out] m Microfacet normal
    \param[out] wi Incident direction after importance sampling the BRDF
    \param[out] pdf Probability density function for choosing the incident direction
*/
float sampleBeckmannDistribution(
	in vec3 wo,
	in vec2 roughness,
	in vec2 rSample,
	_ref(vec3) m,
	_ref(vec3) wi,
	_ref(float) pdf)
{
	float alphaSqr = roughness.x * roughness.x;

	// Sample phi component
	float temp = 2.f * M_PIf * rSample.y;
	float sinPhiM = sin(temp);
	float cosPhiM = cos(temp);

	// Sample theta component
	float tanThetaMSqr = alphaSqr * -log(1.f - rSample.x);
	float cosThetaM = 1.f / sqrt(1.f + tanThetaMSqr);

	// Compute probability density function based on the sampled components
	pdf = (1.f - rSample.x) / (M_PIf * roughness.x * roughness.y * cosThetaM * cosThetaM * cosThetaM);

	// Sanity check
	if (pdf < 1e-20f)
		pdf = 0.f;

	// Sample microfacet normal
	float sinThetaM = sqrt(max(0.f, 1.f - cosThetaM * cosThetaM));

	m.x = sinThetaM * cosPhiM;
	m.y = sinThetaM * sinPhiM;
	m.z = cosThetaM;

	// Specular reflection based on the microfacet normal
	wi = -wo - 2.f * dot(-wo, m) * m;
	if (wi.z <= 0.f || pdf <= 0.f)
		return 0.f;

	float weight = evalBeckmannDistribution(m, roughness) * dot(wo, m) / (pdf * wo.z);

	// Cook-Torrance Jacobian
	pdf /= 4.f * dot(wi, m);

	return weight;
}

/**
    Sample the microfacet BRDF using GGX normal distribution function

    \param[in] wo Outgoing direction towards the camera
    \param[in] roughness Material roughness
    \param[in] rSample Random numbers for sampling
    \param[out] m Microfacet normal
    \param[out] wi Incident direction after importance sampling the BRDF
    \param[out] pdf Probability density function for choosing the incident direction
*/
float sampleGGXDistribution(
	in vec3 wo,
	in vec2 roughness,
	in vec2 rSample,
	_ref(vec3) m,
	_ref(vec3) wi,
	_ref(float) pdf)
{
	float alphaSqr = roughness.x * roughness.x;

    bool perfectSpecular = alphaSqr <= 1e-6f;

    if(perfectSpecular)
    {
        alphaSqr = 0.f;
        roughness = 0;
    }

	// Sample phi component
	float temp = 2.f * M_PIf * rSample.y;
	float sinPhiM = sin(temp);
	float cosPhiM = cos(temp);

	// Sample theta component
	float tanThetaMSqr = alphaSqr * rSample.x / (1.f - rSample.x);
	float cosThetaM = 1.f / sqrt(1.f + tanThetaMSqr);

	// Compute probability density function based on the sampled components
	temp = 1.f + tanThetaMSqr / alphaSqr;
	pdf = M_1_PIf / (roughness.x * roughness.y * cosThetaM * cosThetaM * cosThetaM * temp * temp);

	// Sanity checks
    if(perfectSpecular)
        pdf = 1.f;
	else if (pdf < 1e-20f)
		pdf = 0.f;

	// Sample microfacet normal
	float sinThetaM = sqrt(max(0.f, 1.f - cosThetaM * cosThetaM));

	m.x = sinThetaM * cosPhiM;
	m.y = sinThetaM * sinPhiM;
	m.z = cosThetaM;

	// Specular reflection based on the microfacet normal
	wi = -wo - 2.f * dot(-wo, m) * m;

	// Sanity check
	if (wi.z <= 0.f || pdf <= 0.f)
		return 0.f;

	float weight = evalGGXDistribution(m, roughness);
    if(perfectSpecular)
        weight = 1.f;
    
    weight *= dot(wo, m) / (pdf * wo.z);

	// Cook-Torrance Jacobian
	pdf /= 4.f * dot(wi, m);

	return weight;
}