using "ShaderConstants.spire";

module GeneralMaterial implements Material
{
    public param bool hasAlphaMap;
    public param bool hasNormalMap;
    public param bool hasHeightMap;
    public param bool hasAmbientMap;
    public param vec2  height;                        // Height (displacement) map modifier (scale, offset). If texture is non-null, one can apply a displacement or parallax mapping
    public param float alphaThreshold; // Alpha test threshold, in cast alpha-test is enabled (alphaMap is not nullptr)
    public param int id;   // Scene-unique material id, -1 is a wrong material
    public param Texture2D alphaMap;         // Alpha test parameter, if texture is non-null, alpha test is enabled, alpha threshold is stored in the constant color
    public param Texture2D normalMap;        // Normal map modifier, if texture is non-null, shading normal is perturbed
    public param Texture2D heightMap;        // Height (displacement) map modifier, if texture is non-null, one can apply a displacement or parallax mapping
    public param Texture2D ambientMap;       // Ambient occlusion map
    public param SamplerState samplerState;
    require vec2 vertUV;

    // general material layer parameters
    param int4 hasTexture;
    param int4 materialType;
    param int4 ndf;
    param int4 blend;
    param int layerCount;

    using layer0 = MaterialLayer(hasTexture.x, materialType.x, ndf.x, blend.x);
    using layer1 = MaterialLayer(hasTexture.y, materialType.y, ndf.y, blend.y);
    using layer2 = MaterialLayer(hasTexture.z, materialType.z, ndf.z, blend.z);

    bool alphaTestPassed(in ShadingAttribs attr)
    {
    #ifndef _MS_DISABLE_ALPHA_TEST
        return sampleTexture(alphaMap, samplerState, attr).x >= alphaThreshold;
    #else
        return true;
    #endif
    }

    void applyAlphaTest(in ShadingAttribs attr)
    {
    #ifndef _MS_DISABLE_ALPHA_TEST
        if (hasAlphaMap)
        {
            if(!alphaTestPassed(attr))
                discard;
        }
    #endif
    }

    vec3 normalToRGB(in vec3 normal)
    {
        return normal * 0.5f + 0.5f;
    }

    vec3 RGBToNormal(in vec3 rgbval)
    {
        return rgbval * 2.f - 1.f;
    }

    vec3 fromLocal(in vec3 v, in vec3 t, in vec3 b, in vec3 n)
    {
        return t * v.x + b * v.y + n * v.z;
    }

    vec3 toLocal(in vec3 v, in vec3 t, in vec3 b, in vec3 n)
    {
        return vec3(dot(v, t), dot(v, b), dot(v, n));
    }

    void applyNormalMap(in vec3 texValue, inout vec3 n, inout vec3 t, inout vec3 b)
    {
        vec3 normalMap = normalize(texValue);
        n = fromLocal(normalMap, normalize(t), normalize(b), normalize(n));
        // Orthogonalize tangent frame
        b = normalize(b - n * dot(b, n));
        t = normalize(cross(b, n));
    }

    void perturbNormal(inout ShadingAttribs attr, bool forceSample)
    {
        if (forceSample || hasNormalMap != 0)
        {
            vec3 texValue = sampleTexture(normalMap, samplerState, attr).rgb;
            applyNormalMap(RGBToNormal(texValue), attr.N, attr.T, attr.B);
        }
    }

    /**	The highest-level material evaluation function.
    This is the main routing for evaluating a complete PBR material, given a shading point and a light source.
    Should be called once per light.
    */
    public void evalMaterial(
        in ShadingAttribs shAttr,
        in LightAttribs lAttr,
        inout ShadingOutput result)
    {
        evalMaterial(shAttr, lAttr, result, false);
    }
    public void evalMaterial(
        in ShadingAttribs shAttr,
        in LightAttribs lAttr,
        inout ShadingOutput result,
        in bool initializeShadingOut)
    {
        /* If it's the first pass, initialize all the aggregates to zero */
        if(initializeShadingOut)
        {
            result.diffuseAlbedo = 0;
            result.diffuseIllumination = 0;
            result.specularAlbedo = 0;
            result.specularIllumination = 0;
            result.finalValue = 0;
            result.effectiveRoughness = 0;
            result.wi = 0;
            result.pdf = 0;
            result.thp = 0;
        }

        /* Go through all layers and perform a layer-by-layer shading and compositing */
        PassOutput passResult;
        passResult.value = 0;
        passResult.diffuseAlbedo = 0;
        passResult.diffuseIllumination = 0;
        passResult.specularAlbedo = 0;
        passResult.specularIllumination = 0;
        passResult.roughness = 0;
        passResult.effectiveRoughness = 0;

        if (materialType.x != 0)
            layer0.evalMaterialLayer(shAttr, lAttr, passResult);
        if (materialType.y != 0)
            layer1.evalMaterialLayer(shAttr, lAttr, passResult);
        if (materialType.z != 0)
            layer2.evalMaterialLayer(shAttr, lAttr, passResult);

        /* Accumulate the results of the pass */
        result.finalValue += passResult.value;
        result.effectiveRoughness += passResult.effectiveRoughness / max(1e-3f, luminance(passResult.value));
        result.diffuseIllumination += passResult.diffuseIllumination;
        result.specularIllumination += passResult.specularIllumination;
        result.diffuseAlbedo = passResult.diffuseAlbedo;
        result.specularAlbedo = passResult.specularAlbedo;
    }

    /**
    Another overload of material evaluation function, which prepares light attributes internally.
    */
    public void evalMaterial(
        in ShadingAttribs shAttr,
        in LightData light,
        inout ShadingOutput result,
        in bool initializeShadingOut)
    {
        /* Prepare lighting attributes */
        LightAttribs LAttr;
        prepareLightAttribs(light, shAttr, LAttr);

        /* Evaluate material with lighting attributes */
        evalMaterial(shAttr, LAttr, result, initializeShadingOut);
    }
    public void evalMaterial(
        in ShadingAttribs shAttr,
        in LightData light,
        inout ShadingOutput result)
    {
        evalMaterial(shAttr, light, result, false);
    }


    /**
    Prepares all light-independent attributes needed to perform shading at a hit point.
    This includes fetching all textures and computing final shading attributes, like albedo and roughness.
    After this step, one can save these shading attributes, e.g., in a G-Buffer to perform lighting afterwards.
    This routine also applies all material modifiers, like performs alpha test and applies a normal map.
    */
    void prepareShadingAttribs(in vec3 P, in vec3 camPos,
        in vec3 normal, in vec3 bitangent, in vec2 uv,
    #ifdef _MS_USER_DERIVATIVES
        in vec2 dPdx, in vec2 dPdy,
    #else
        in float lodBias,
    #endif
        inout ShadingAttribs shAttr)
    {
        /* Prepare shading attributes */
        shAttr.P = P;
        shAttr.E = normalize(camPos - P);
        shAttr.N = normalize(normal);
        shAttr.B = normalize(bitangent - shAttr.N * (dot(bitangent, shAttr.N)));
        shAttr.T = normalize(cross(shAttr.B, shAttr.N));
        shAttr.UV = uv;
    #ifdef _MS_USER_DERIVATIVES
        shAttr.DPDX = dPdx;
        shAttr.DPDY = dPdy;
    #else
        shAttr.lodBias = lodBias;
    #endif

        /* Evaluate alpha test material modifier */
        applyAlphaTest(shAttr);
        shAttr.aoFactor = 1;

        /* Perturb shading normal is needed */
        perturbNormal(shAttr, false);
    }

    /**
    Another overload of PrepareShadingAttribs(), which does not require tangents.
    Instead it constructs a world-space axis-aligned tangent frame on the fly.
    */
    void prepareShadingAttribs(in vec3 P, in vec3 camPos,
        in vec3 normal, in vec2 uv,
    #ifdef _MS_USER_DERIVATIVES
        in vec2 dPdx, in vec2 dPdy,
    #else
        in float lodBias,
    #endif
        inout ShadingAttribs shAttr)
    {
        /* Generate an axis-aligned tangent frame */
        vec3 bitangent;
        createTangentFrame(normal, bitangent);

        prepareShadingAttribs(P, camPos, normal, bitangent, uv,
    #ifdef _MS_USER_DERIVATIVES
            dPdx, dPdy,
    #else
            lodBias,
    #endif
            shAttr);
    }
}